// Generated by CoffeeScript 1.10.0
(function() {
  var CANNON, DUTYCYCLE, DUTYTIMER, GAMELOOP, Item, Queue, TIMESTEP, U, _CFG, _PLAYERS, _ROOMS, _UINFO, _pCFG, _pUINFO, app, configCheck, express, gen_item, gen_player, gen_playerinfo, gen_room, http, initroom, io, ipaddress, jsonfile, serverport;

  U = require('./lib/util');

  CANNON = require('cannon');

  jsonfile = require('jsonfile');

  express = require('express');

  app = express();

  http = require('http').Server(app);

  io = require('socket.io')(http);

  TIMESTEP = 1.0 / 60.0;

  _pCFG = 'data/cfg.json';

  _CFG = jsonfile.readFileSync(_pCFG);

  _pUINFO = 'data/uinfo.json';

  _UINFO = jsonfile.readFileSync(_pUINFO);

  configCheck = function() {
    var _INVLD_CFG;
    _INVLD_CFG = function(cause) {
      throw new Error("CONFIG INVALID: " + cause);
    };
    if (_CFG.room.PSIDES > _CFG.room.radius) {
      _INVLD_CFG("Sides intersect center!");
    }
    if (_CFG.room.PSPAWN > _CFG.room.radius) {
      _INVLD_CFG("Spawn planes intersect center!");
    }
    if (_CFG.room.PSPAWN > _CFG.room.PSIDES) {
      _INVLD_CFG("Players will spawn in neutral ground!");
    }
    if (_CFG.room.PJAILS > _CFG.room.radius) {
      _INVLD_CFG("Jail planes intersect center!");
    }
    if (_CFG.room.PJAILS > _CFG.room.PSIDES) {
      _INVLD_CFG("Jail planes enter neutral ground!");
    }
    if (_CFG.room.PJAILS > _CFG.room.PSPAWN) {
      return _INVLD_CFG("Players will spawn behind jail planes!");
    }
  };

  app.use(express["static"](__dirname + '/../client'));

  Array.prototype.remove = function(o) {
    if (this.indexOf(o) >= 0) {
      return this.splice(this.indexOf(o), 1);
    } else {
      return console.error("Element not in array!");
    }
  };

  _PLAYERS = [];

  _ROOMS = [];

  Item = {
    NONE: 0,
    BOOST: 5,
    RUBBER: 10,
    BLOCK: 11,
    STEALTH: 15,
    WEIGHT: 21,
    FEATHER: 22,
    FLAG: 20
  };

  gen_playerinfo = function(socket, iname) {
    var playerinfo;
    console.log("Generated new playerinfo");
    playerinfo = {
      id: socket.id,
      name: iname,
      color: U.randColor(),
      skin: false
    };
    console.dir(playerinfo);
    return playerinfo;
  };

  gen_player = function(playerinfo) {
    var ibody, ishape, player;
    console.log("Generated new player from playerinfo");
    ishape = new CANNON.Sphere(_CFG.player.radius);
    ibody = new CANNON.Body(_CFG.player.mass, ishape);
    ibody.position.set(0, 0, 0);
    player = {
      info: playerinfo,
      body: ibody,
      item: Item.NONE,
      jailed: false,
      team: -1,
      room: null
    };
    return player;
  };

  gen_room = function(iid) {
    var iworld, room;
    iworld = new CANNON.World();
    iworld.gravity.set(0, 0, 0);
    iworld.broadphase = new CANNON.NaiveBroadphase();
    return room = {
      id: iid,
      players: [],
      world: iworld,
      chat: [],
      excise: function(player) {
        this.players.remove(player);
        this.world.removeBody(player.body);
        console.log(player.info.name + " was removed from room " + this.id);
      },
      getset: function(T, time) {
        if (time === 0) {
          return T.start();
        } else {
          console.log("room " + T.id + ": T-" + time);
          return setTimeout(T.getset, 1000, T, (time - 1) | 0);
        }
      },
      start: function() {
        _ROOMS.push(this);
        return console.log("room " + this.id + " started");
      },
      stop: function() {
        _ROOMS.remove(this);
        return console.log("room " + this.id + " stopped");
      }
    };
  };

  gen_item = function(itype) {
    var ibody, ishape, item;
    ishape = new CANNON.Sphere(_CFG.item.radius);
    ibody = new CANNON.Body(_CFG.item.mass, ishape);
    ibody.position.set(0, 0, 0);
    return item = {
      type: itype,
      body: ibody
    };
  };

  initroom = function(room, players) {
    var coords, i, len, objects, player, shellBody, shellShape;
    objects = [];
    shellShape = new CANNON.Sphere(_CFG.room.radius);
    shellBody = new CANNON.Body(0, shellShape);
    shellBody.position.set(0, 0, 0);
    room.world.addBody(shellBody);
    objects.push({
      name: "shell",
      radius: _CFG.room.radius,
      mass: 0,
      position: [0, 0, 0]
    });
    coords = U.playerCoords(_CFG.room);
    for (var i = 0; i < players.length; i++) {
		var player = players[i];

		// distribute position of players
		player.body.position.set(coords[i][0],coords[i][1],coords[i][2]);
		console.log(player.info.name+" coords@ "+player.body.position);

		// assign room
		player.room = room;
		room.world.addBody(player.body);
		room.players.push(player);
		console.log("added "+player.info.name+" to room "+room.id);

		// add player to objects array
		objects.push({
			name: "player",
			info: player.info,
			team: player.team,
			id: player.socket.id,
			radius: _CFG.player.radius,
			mass: _CFG.player.mass,
			position: coords[i]
			});
	};
    for (i = 0, len = players.length; i < len; i++) {
      player = players[i];
      player.socket.emit('roomJoin', objects, player.socket.id);
    }
    room.getset(room, 5);
  };

  Queue = {
    __queue: [],
    excise: function(player) {
      var prevlength;
      prevlength = this.__queue.length;
      this.__queue.remove(player);
      if (prevlength > this.__queue.length) {
        return console.log("player successfully removed");
      } else {
        return console.log("error: player not removed");
      }
    },
    queue: function(player) {
      newroom;
      var newroom, t;
      t = _CFG.room.teams;
      player.team = this.__queue.length % t;
      this.__queue.push(player);
      player.room = this.__queue;
      console.log("added " + player.info.name + " to queue");
      console.log(this.__queue.length + " players in queue");
      if (this.__queue.length === _CFG.room.playersPerTeam * t) {
        newroom = gen_room(_ROOMS.length);
        initroom(newroom, this.__queue);
        this.__queue = [];
        return;
      }
    }
  };

  DUTYTIMER = 0;

  DUTYCYCLE = function() {
    var aroom, i, len, results;
    DUTYTIMER++;
    DUTYTIMER %= 60;
    results = [];
    for (i = 0, len = _ROOMS.length; i < len; i++) {
      aroom = _ROOMS[i];
      results.push(aroom.world.step(TIMESTEP));
    }
    return results;
  };

  io.on('connection', function(socket) {
    socket.AUTH = true;
    console.log("CONNECTION RECEIVED FROM " + socket.id + " @" + socket.request.connection.remoteAddress + " : " + socket.request.connection.remotePort);
    socket.pinfo = {
      name: "unnamed player"
    };
    socket.on('validate_s', function(key) {
      var result;
      result = U.validate(key, _CFG.pass.hash, _CFG.pass.salt);
      socket.AUTH = result;
      return socket.emit('validate_r', result);
    });
    socket.on('entry_guest', function(name) {
      if (!socket.AUTH) {
        return false;
      }
      socket.pinfo = gen_playerinfo(socket, name);
      socket.player = gen_player(socket.pinfo);
      socket.player.socket = socket;
      _PLAYERS.push(socket.player);
      return Queue.queue(socket.player);
    });
    return socket.on('disconnect', function() {
      if (socket.player != null) {
        _PLAYERS.remove(socket.player);
        console.log(socket.pinfo.name + " has left");
        if (socket.player.room === Queue.__queue) {
          debugger;
          Queue.excise(socket.player);
          console.log(socket.pinfo.name + " was removed from queue");
          return socket.player.room = null;
        } else if (socket.player.room != null) {
          return socket.player.room.excise(socket.player);
        }
      }
    });
  });

  GAMELOOP = setInterval(DUTYCYCLE, TIMESTEP);

  ipaddress = process.env.OPENSHIFT_NODEJS_IP || process.env.IP || '127.0.0.1';

  serverport = process.env.OPENSHIFT_NODEJS_PORT || process.env.PORT || _CFG.port;

  if (process.env.OPENSHIFT_NODEJS_IP != null) {
    http.listen(serverport, ipaddress, function() {
      return console.log('[DEBUG] Listening on *:' + serverport);
    });
    return;
  } else {
    http.listen(serverport, function() {
      return console.log('[DEBUG] Listening on *:' + _CFG.port);
    });
    return;
  }

}).call(this);
